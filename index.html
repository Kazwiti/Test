<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Truth or Dare - Extremely Naughty Edition</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    text-align: center;
    padding: 20px;
  }
  input, select, button {
    padding: 10px 15px;
    margin: 5px;
    font-size: 1rem;
    border-radius: 8px;
    border: none;
  }
  button {
    cursor: pointer;
  }
  button:disabled {
    opacity: 0.5;
    cursor: default;
  }
  #player-list {
    margin: 10px 0;
    font-weight: bold;
  }
  #challenge {
    margin-top: 30px;
    padding: 20px;
    background: #222;
    border-radius: 12px;
    min-height: 100px;
    max-width: 400px;
    margin-left: auto;
    margin-right: auto;
  }
  #challenge p {
    font-size: 1.2rem;
    user-select: text;
  }
  label {
    font-weight: bold;
  }
  #mode-select {
    margin-top: 15px;
  }

  /* small lobby area styling */
  #lobby {
    margin-bottom: 12px;
  }
  #roomInfo {
    margin-top: 8px;
    font-size: 0.95rem;
    color: #ddd;
  }
</style>
</head>
<body>

<h1>Truth or Dare - Extremely Naughty Edition</h1>

<!-- Multiplayer lobby controls (non-intrusive) -->
<div id="lobby">
  <input type="text" id="roomInput" placeholder="Enter or create room code" aria-label="Room code" />
  <button id="createRoomBtn">Create Room</button>
  <button id="joinRoomBtn">Join Room</button>
  <div id="roomInfo" aria-live="polite"></div>
</div>

<!-- Existing player input area -->
<div>
  <input type="text" id="player-name" placeholder="Enter player name" aria-label="Player name" />
  <label for="player-gender">Gender:</label>
  <select id="player-gender" aria-label="Player gender">
    <option value="male" selected>Male</option>
    <option value="female">Female</option>
  </select>
  <button id="addPlayerBtn">Add Player</button>
</div>

<div id="player-list" aria-live="polite" aria-atomic="true">Players: None</div>

<div id="mode-select">
  <label for="mode">Choose game mode:</label>
  <select id="mode" aria-label="Game mode">
    <option value="spicy" selected>Extremely Naughty</option>
    <option value="fun">Fun</option>
  </select>
</div>

<div>
  <button id="truthBtn" disabled>Truth</button>
  <button id="dareBtn" disabled>Dare</button>
</div>

<div id="challenge" role="region" aria-live="polite" aria-atomic="true">
  <p>Add players to start the game!</p>
</div>

<!-- Firebase Realtime Database (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
  // --- Firebase config with your actual project values ---
  const firebaseConfig = {
    apiKey: "AIzaSyDNSy0zdokELU4CxSoy7zJXHAuBPQqLaO0",
    authDomain: "truthor-dare-multiplayer.firebaseapp.com",
    databaseURL: "https://truthor-dare-multiplayer-default-rtdb.firebaseio.com",
    projectId: "truthor-dare-multiplayer",
    storageBucket: "truthor-dare-multiplayer.appspot.com",
    messagingSenderId: "51895740835",
    appId: "1:51895740835:web:783c3755a60ca0ad831216"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const rdb = firebase.database();

  // Multiplayer session variables
  let gameId = null; // the room code / session id
  let isSyncing = false; // true when connected to a game
  const localClientId = Math.random().toString(36).slice(2,10); // small id for this browser instance

  const roomInput = document.getElementById('roomInput');
  const createRoomBtn = document.getElementById('createRoomBtn');
  const joinRoomBtn = document.getElementById('joinRoomBtn');
  const roomInfo = document.getElementById('roomInfo');

  createRoomBtn.addEventListener('click', () => {
    // generate a simple 6-char room code
    const code = Math.random().toString(36).slice(2,8).toUpperCase();
    // set URL param and start session
    const newUrl = new URL(window.location.href);
    newUrl.searchParams.set('game', code);
    window.history.replaceState({}, '', newUrl);
    roomInput.value = code;
    startSession(code);
  });

  joinRoomBtn.addEventListener('click', () => {
    const code = roomInput.value.trim().toUpperCase();
    if (!code) {
      alert('Enter a room code to join or create one.');
      return;
    }
    // set URL param and start session
    const newUrl = new URL(window.location.href);
    newUrl.searchParams.set('game', code);
    window.history.replaceState({}, '', newUrl);
    startSession(code);
  });

  // Auto-join if ?game=CODE present
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has('game')) {
    const code = urlParams.get('game').toUpperCase();
    roomInput.value = code;
    startSession(code);
  }

  // helper to set room info text
  function setRoomInfo(text) {
    roomInfo.textContent = text;
  }
</script>

<script>  
  // --- Firebase config: REPLACE placeholders with your real Firebase config ---  
  const firebaseConfig = {  
    apiKey: "YOUR_API_KEY",  
    authDomain: "game-project.firebaseapp.com",  
    databaseURL: "https://game-project-default-rtdb.firebaseio.com",  
    projectId: "game-project",  
    storageBucket: "game-project.appspot.com",  
    messagingSenderId: "YOUR_MESSAGING_SENDER_ID",  
    appId: "YOUR_APP_ID"  
  };  
  
  // Initialize Firebase  
  firebase.initializeApp(firebaseConfig);  
  const rdb = firebase.database();  
  
  // Multiplayer session variables  
  let gameId = null; // the room code / session id  
  let isSyncing = false; // true when connected to a game  
  const localClientId = Math.random().toString(36).slice(2,10); // small id for this browser instance  
  
  const roomInput = document.getElementById('roomInput');  
  const createRoomBtn = document.getElementById('createRoomBtn');  
  const joinRoomBtn = document.getElementById('joinRoomBtn');  
  const roomInfo = document.getElementById('roomInfo');  
  
  createRoomBtn.addEventListener('click', () => {  
    // generate a simple 6-char room code  
    const code = Math.random().toString(36).slice(2,8).toUpperCase();  
    // set URL param and start session  
    const newUrl = new URL(window.location.href);  
    newUrl.searchParams.set('game', code);  
    window.history.replaceState({}, '', newUrl);  
    roomInput.value = code;  
    startSession(code);  
  });  
  
  joinRoomBtn.addEventListener('click', () => {  
    const code = roomInput.value.trim().toUpperCase();  
    if (!code) {  
      alert('Enter a room code to join or create one.');  
      return;  
    }  
    // set URL param and start session  
    const newUrl = new URL(window.location.href);  
    newUrl.searchParams.set('game', code);  
    window.history.replaceState({}, '', newUrl);  
    startSession(code);  
  });  
  
  // Auto-join if ?game=CODE present  
  const urlParams = new URLSearchParams(window.location.search);  
  if (urlParams.has('game')) {  
    const code = urlParams.get('game').toUpperCase();  
    roomInput.value = code;  
    startSession(code);  
  }  
  
  // helper to set room info text  
  function setRoomInfo(text) {  
    roomInfo.textContent = text;  
  }  
  
  // --- Added multiplayer realtime sync ---  
  
  // Start or join a game session (room) and sync game state via Realtime Database  
  function startSession(code) {  
    if (isSyncing) {  
      // If already syncing with another session, detach previous listeners  
      rdb.ref(`games/${gameId}/players`).off();  
      rdb.ref(`games/${gameId}/currentChallenge`).off();  
      rdb.ref(`games/${gameId}/mode`).off();  
    }  
  
    gameId = code;  
    isSyncing = true;  
    setRoomInfo(`Joined room: ${gameId}`);  
  
    // Listen for player list changes  
    rdb.ref(`games/${gameId}/players`).on('value', snapshot => {  
      const playersData = snapshot.val() || {};  
      // Update local players array with synced data  
      // Convert object to array  
      players.length = 0; // clear existing  
      for (const key in playersData) {  
        players.push(playersData[key]);  
      }  
      updatePlayerList();  
      updateButtonsState();  
    });  
  
    // Listen for current challenge changes  
    rdb.ref(`games/${gameId}/currentChallenge`).on('value', snapshot => {  
      const challenge = snapshot.val();  
      if (challenge) {  
        showChallenge(challenge);  
      } else {  
        resetChallenge();  
      }  
    });  
  
    // Listen for game mode changes  
    rdb.ref(`games/${gameId}/mode`).on('value', snapshot => {  
      const newMode = snapshot.val();  
      if (newMode) {  
        mode = newMode;  
        modeSelect.value = mode;  
      }  
    });  
  }  
  
  // Show challenge text in UI  
  function showChallenge(challengeObj) {  
    challengeDiv.innerHTML = `<p><strong>${challengeObj.player}</strong> chose <em>${challengeObj.type}</em>: ${challengeObj.text}</p>`;  
  }  
</script>

<script>
  // Utility
  function pickRandom(array) {
    return array[Math.floor(Math.random() * array.length)];
  }

  // Compose the challenge object (player, type, text)
  function buildChallengeObj(player, type, text) {
    return { player, type, text, byClient: localClientId, timestamp: Date.now() };
  }

  // When a challenge is generated locally, if in session we push it to DB so others see it.
  function pushChallengeToDB(challengeObj) {
    if (!isSyncing || !gameId) return;
    rdb.ref(`games/${gameId}/currentChallenge`).set(challengeObj).catch(err => console.error(err));
  }

  // When scores update (local completion), sync to DB
  function pushScoresToDB(scoreboard) {
    if (!isSyncing || !gameId) return;
    rdb.ref(`games/${gameId}/scoreboard`).set(scoreboard).catch(err => console.error(err));
  }

  // Get challenge (returns object, but also if syncing will write to DB)
  function getChallenge(type) {
    if (players.length === 0) {
      return { player: null, text: "Add players first!" };
    }
    const player = pickRandom(players);
    if (mode === "spicy") {
      if (type === "truth") {
        const text = pickRandom(spicyTruths);
        const obj = buildChallengeObj(player, "truth", text);
        // sync
        pushChallengeToDB(obj);
        return { player, text };
      } else {
        const filteredDares = spicyDares.filter(
          (d) => d.gender === "both" || d.gender === player.gender
        );
        if (filteredDares.length === 0) {
          return { player, text: "No dares available for this gender." };
        }
        const text = pickRandom(filteredDares).text;
        const obj = buildChallengeObj(player, "dare", text);
        pushChallengeToDB(obj);
        return { player, text };
      }
    } else { // fun
      if (type === "truth") {
        const text = pickRandom(funTruths);
        const obj = buildChallengeObj(player, "truth", text);
        pushChallengeToDB(obj);
        return { player, text };
      } else {
        const text = pickRandom(funDares);
        const obj = buildChallengeObj(player, "dare", text);
        pushChallengeToDB(obj);
        return { player, text };
      }
    }
  }

  // Display helper (also used when DB pushes a new challenge)
  function showChallengeForClient(challengeObj) {
    if (!challengeObj || !challengeObj.player) {
      challengeDiv.innerHTML = `<p>${challengeObj && challengeObj.text ? challengeObj.text : "Add players first!"}</p>`;
      return;
    }
    const name = challengeObj.player.name || challengeObj.player;
    const capType = challengeObj.type ? challengeObj.type.charAt(0).toUpperCase() + challengeObj.type.slice(1) : "Challenge";
    challengeDiv.innerHTML = `<p><strong>${name}'s ${capType}:</strong> ${challengeObj.text}</p>`;
  }

  // Event handlers for buttons - these will generate challenge and push to DB inside getChallenge()
  truthBtn.addEventListener("click", () => {
    const result = getChallenge("truth");
    if (!result.player) {
      challengeDiv.innerHTML = `<p>${result.text}</p>`;
    } else {
      challengeDiv.innerHTML = `<p><strong>${result.player.name}'s Truth:</strong> ${result.text}</p>`;
    }
  });

  dareBtn.addEventListener("click", () => {
    const result = getChallenge("dare");
    if (!result.player) {
      challengeDiv.innerHTML = `<p>${result.text}</p>`;
    } else {
      challengeDiv.innerHTML = `<p><strong>${result.player.name}'s Dare:</strong> ${result.text}</p>`;
    }
  });

  // Scoreboard: keep local object and sync to DB when updated
  const scoreboard = {}; // { playerName: points }

  // UI helper to update scoreboard area (we'll create a small scoreboard display under challenge)
  function renderScoreboard() {
    let sb = document.getElementById('scoreboard');
    if (!sb) {
      sb = document.createElement('div');
      sb.id = 'scoreboard';
      sb.style.maxWidth = '400px';
      sb.style.margin = '14px auto';
      sb.style.background = '#222';
      sb.style.borderRadius = '8px';
      sb.style.padding = '10px';
      sb.style.textAlign = 'left';
      challengeDiv.parentNode.insertBefore(sb, challengeDiv.nextSibling);
    }
    let html = '<strong>Scoreboard</strong><ul style="list-style:none;padding:6px 0;margin:0;">';
    if (players.length === 0) html += '<li>No players yet.</li>';
    players.forEach(p => {
      const pts = scoreboard[p.name] || 0;
      html += `<li>${p.name}: ${pts} point${pts === 1 ? '' : 's'}</li>`;
    });
    html += '</ul>';
    sb.innerHTML = html;
  }

  // When a player completes a challenge, call this to award a point
  // (you can wire this to the manual Completed button you asked for earlier)
  function awardPoint(playerName) {
    scoreboard[playerName] = (scoreboard[playerName] || 0) + 1;
    renderScoreboard();
    pushScoresToDB(scoreboard);
  }

  // Provide failing (no points) function too
  function failChallenge() {
    // no score change, but we could push a history if desired
  }
</script>
<script>
  // Start session helper - attaches listeners and initializes game node if missing
  function startSession(code) {
    if (!code) return;
    gameId = code;
    isSyncing = true;
    setRoomInfo(`Connected to room: ${gameId} — syncing in real time`);
    // create games/{gameId} if not exists (no overwrite)
    const gameRef = rdb.ref(`games/${gameId}`);
    gameRef.once('value').then(snap => {
      if (!snap.exists()) {
        // initialize structure
        gameRef.set({
          createdAt: Date.now(),
          mode: mode,
          currentChallenge: null,
          scoreboard: {},
          players: {}
        }).catch(err => console.error(err));
      }
    }).catch(err => console.error(err));

    // Listen players
    rdb.ref(`games/${gameId}/players`).on('value', snap => {
      // update local players array (mirror)
      players.length = 0; // clear
      const playersObj = snap.val() || {};
      Object.keys(playersObj).forEach(k => {
        const p = playersObj[k];
        players.push({ name: p.name, gender: p.gender });
        // ensure scoreboard entry exists locally
      });
      updatePlayerList();
      updateButtonsState();
      renderScoreboard();
    });

    // Listen mode
    rdb.ref(`games/${gameId}/mode`).on('value', snap => {
      const m = snap.val();
      if (m) {
        mode = m;
        modeSelect.value = m;
      }
    });

    // Listen currentChallenge
    rdb.ref(`games/${gameId}/currentChallenge`).on('value', snap => {
      const cc = snap.val();
      if (!cc) {
        // nothing
        return;
      }
      // update UI with the challenge from DB
      showChallengeForClient(cc);
    });

    // Listen scoreboard
    rdb.ref(`games/${gameId}/scoreboard`).on('value', snap => {
      const sb = snap.val() || {};
      // copy into local scoreboard
      Object.keys(sb).forEach(k => scoreboard[k] = sb[k]);
      renderScoreboard();
    });

    // Clean-up on disconnect of this client: optionally remove this client-specific data
    // We don't delete players automatically, because players are real entries; user must remove manually.
  }

  // Optional: function to remove a player (local UI can call this). If connected, remove from DB.
  function removePlayer(name) {
    const key = name.toLowerCase();
    if (isSyncing && gameId) {
      rdb.ref(`games/${gameId}/players/${key}`).remove().catch(err => console.error(err));
    } else {
      const idx = players.findIndex(p => p.name.toLowerCase() === name.toLowerCase());
      if (idx >= 0) {
        players.splice(idx,1);
        updatePlayerList();
        updateButtonsState();
      }
    }
  }

  // Provide simple Completed/Failed buttons under challenge to manually award points (UI creation)
  (function createCompletionButtons() {
    const existing = document.getElementById('completionButtons');
    if (existing) return;
    const div = document.createElement('div');
    div.id = 'completionButtons';
    div.style.marginTop = '12px';
    div.innerHTML = `
      <input id="completePlayerInput" placeholder="Player who completed (name)" style="padding:8px;border-radius:6px;border:none;margin-right:6px;" />
      <button id="completedBtn" style="background-color:#4CAF50;color:#fff;">Completed</button>
      <button id="failedBtn" style="background-color:#f44336;color:#fff;margin-left:6px;">Failed</button>
    `;
    challengeDiv.parentNode.insertBefore(div, challengeDiv.nextSibling);

    document.getElementById('completedBtn').addEventListener('click', () => {
      const pname = document.getElementById('completePlayerInput').value.trim();
      if (!pname) return alert('Enter player name who completed the challenge.');
      awardPoint(pname);
      document.getElementById('completePlayerInput').value = '';
      // Optionally clear current challenge in DB
      if (isSyncing && gameId) rdb.ref(`games/${gameId}/currentChallenge`).set(null);
      challengeDiv.innerHTML = "<p>Choose Truth or Dare and have fun!</p>";
    });

    document.getElementById('failedBtn').addEventListener('click', () => {
      const pname = document.getElementById('completePlayerInput').value.trim();
      document.getElementById('completePlayerInput').value = '';
      if (isSyncing && gameId) rdb.ref(`games/${gameId}/currentChallenge`).set(null);
      challengeDiv.innerHTML = "<p>Challenge failed — next turn!</p>";
    });
  })();

  // Ensure local UI initial state
  updatePlayerList();
  updateButtonsState();
  renderScoreboard();
</script>
</body>
</html>